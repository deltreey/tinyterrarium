<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Tiny Terrarium Pet</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        :root {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        canvas {
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 1rem;
            background: #f2f5f7;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
        }

        h1 {
            margin: 0;
            font-size: 1.4rem;
            text-align: center;
        }

        .subtitle {
            font-size: 0.9rem;
            color: #444;
            text-align: center;
            max-width: 420px;
            line-height: 1.3;
        }

        #game-container {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            border-radius: 16px;
            overflow: hidden;
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 420px;
        }

        button {
            padding: 0.45rem 0.9rem;
            border-radius: 999px;
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .btn-water {
            background: #4caf50;
            color: #fff;
        }

        .btn-light {
            background: #ffca28;
            color: #333;
        }

        .btn-clean {
            background: #90caf9;
            color: #123;
        }

        .btn-reset {
            background: #e0e6ea;
            color: #333;
        }

        .btn-decor {
            background: #d7c7ff;
            color: #2a1a4a;
        }

        button:active {
            transform: translateY(1px);
        }

        .difficulty {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .difficulty-title {
            font-weight: 500;
        }

        #difficulty-slider {
            flex: 1;
        }

        .difficulty-label {
            min-width: 3.5rem;
            text-align: right;
            color: #444;
        }

        .drawer-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.25);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
        }

        .drawer {
            position: fixed;
            left: 0;
            right: 0;
            bottom: -320px;
            background: #fff;
            border-top-left-radius: 18px;
            border-top-right-radius: 18px;
            box-shadow: 0 -8px 24px rgba(0, 0, 0, 0.2);
            padding: 0.75rem;
            transition: bottom 0.18s ease;
            max-width: 520px;
            margin: 0 auto;
        }

        .drawer.open {
            bottom: 0;
        }

        .drawer-backdrop.open {
            opacity: 1;
            pointer-events: auto;
        }

        .drawer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .drawer-title {
            font-weight: 600;
        }

        .drawer-close {
            border: none;
            background: #e0e6ea;
            border-radius: 999px;
            padding: 0.35rem 0.7rem;
            cursor: pointer;
        }

        .sticker-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.5rem;
        }

        .sticker-btn {
            border: none;
            background: #f2f5f7;
            border-radius: 14px;
            padding: 0.75rem;
            font-size: 1rem;
            cursor: pointer;
        }

        .drawer-hint {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            color: #666;
        }

        .footer {
            font-size: 0.75rem;
            color: #777;
            text-align: center;
            max-width: 420px;
        }
    </style>
</head>

<body>
    <h1>Tiny Terrarium Pet</h1>
    <div class="subtitle">
        Merry Christmas! üéÑ Keep your tiny cactus watered, sunny, and clean.
        If you ignore it, it will get grumpy‚Ä¶ or worse.
    </div>

    <div id="game-container"></div>

    <div class="difficulty">
        <span class="difficulty-title">Difficulty:</span>
        <input type="range" id="difficulty-slider" min="0" max="2" step="1" value="1" />
        <span id="difficulty-label" class="difficulty-label">Normal</span>
    </div>


    <div class="controls">
        <button class="btn-water" onclick="giveWater()">Water</button>
        <button class="btn-light" onclick="giveLight()">Sunshine</button>
        <button class="btn-clean" onclick="cleanJar()">Clean jar</button>
        <button class="btn-reset" onclick="resetPet()">New cactus</button>
        <button class="btn-decor" onclick="toggleStickerDrawer()">Decorate ‚ú®</button>
    </div>

    <!-- Sticker drawer (hidden by default) -->
    <!-- <div id="sticker-drawer-backdrop" class="drawer-backdrop" onclick="toggleStickerDrawer(false)"></div> -->
    <div id="sticker-drawer" class="drawer">
        <div class="drawer-header">
            <div class="drawer-title">Stickers</div>
            <button class="drawer-close" onclick="toggleStickerDrawer(false)">Close</button>
        </div>

        <div class="sticker-grid">
            <button class="sticker-btn" onclick="addSticker(0)">Santa Hat</button>
            <button class="sticker-btn" onclick="addSticker(1)">Wreath</button>
        </div>

        <div class="drawer-hint">Tip: drag stickers onto the jar.</div>
    </div>


    <div class="footer">
        Your cactus lives in this browser only. Close the tab if you want to test what
        happens when you abandon it for a while.
    </div>

    <script>
        const STORAGE_KEY = "tiny_terrarium_pet_v1";

        let pet;
        let lastUpdateMs = 0;
        let jarImg;
        let jarOpenImg;
        let cactusImg;
        let happyCactusImg;
        let okCactusImg;
        let sadCactusImg;
        let deadCactusImg;
        let decorateOpen = false;


        let stickerImgs = [];
        let stickerSizes = [];

        // sticker drag state
        let activeStickerIndex = -1;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // cache jar placement used by render + sticker spawn
        let jarRect = { x: 0, y: 0, w: 0, h: 0 };
        const trashRect = { x: 0, y: 0, w: 72, h: 72 }; // canvas-space


        function preload() {
            // load sprite images
            jarImg = loadImage("jar.png");
            jarOpenImg = loadImage("jar_lidopen.png");
            happyCactusImg = loadImage("happy_cactus.png?v=2");
            okCactusImg = loadImage("ok_cactus.png");
            sadCactusImg = loadImage("sad_cactus.png");
            deadCactusImg = loadImage("dead_cactus.png");
            // stickers (transparent PNGs)
            stickerImgs.push(loadImage("sticker_santa_hat.png?v=1"));
            stickerSizes.push({ w: 120, h: 120 });
            stickerImgs.push(loadImage("sticker_wreath.png?v=1"));
            stickerSizes.push({ w: 120, h: 120 });

            cactusImg = happyCactusImg;
        }

        const difficultyLevels = [
            { label: "Chill", decayFactor: 0.045, healthFactor: 0.8 },
            // Normal: baseline
            { label: "Normal", decayFactor: 0.11, healthFactor: 1.0 },
            // Hard: punishing decay, slightly stronger swings
            { label: "Hard", decayFactor: 0.5, healthFactor: 1.3 }
        ];

        function getDifficulty(p) {
            const idx =
                p && typeof p.difficultyIndex === "number"
                    ? p.difficultyIndex
                    : 1;
            return difficultyLevels[idx];
        }

        function newPet() {
            const now = Date.now();
            return {
                name: "Tiny Terrarium",
                moisture: 60,
                light: 60,
                clean: 80,
                health: 80,
                dead: false,
                createdAt: now,
                timeOfDeath: null,
                ageSeconds: 0,
                born: Date.now(),
                stickers: [],
                lastRealTime: now,
                difficultyIndex: 1, // 0 = easy, 1 = normal, 2 = hard
                _saveAccumulator: 0 // internal, not part of the ‚Äúfantasy‚Äù
            };
        }

        function loadPet() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return null;
                const saved = JSON.parse(raw);
                // Merge with defaults in case you add fields later
                let p = Object.assign(newPet(), saved);
                if (!Array.isArray(p.stickers)) p.stickers = [];
                if (typeof p.difficultyIndex !== "number") {
                    p.difficultyIndex = 1;
                }
                const now = Date.now();
                const last = saved.lastRealTime || saved.createdAt || now;
                const elapsedMinutes = (now - last) / 60000;

                if (elapsedMinutes > 0) {
                    applyOfflineDecay(p, elapsedMinutes);
                }
                p._saveAccumulator = 0;
                return p;
            } catch (e) {
                return null;
            }
        }

        function savePet() {
            try {
                const data = Object.assign({}, pet, { lastRealTime: Date.now() });
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                // ignore quota or private mode errors
            }
        }

        function applyOfflineDecay(p, minutes) {
            const seconds = minutes * 60;
            const d = getDifficulty(p);

            const moistureDecayPerSec = 0.3 * d.decayFactor;
            const lightDecayPerSec = 0.2 * d.decayFactor;
            const cleanDecayPerSec = 0.05 * d.decayFactor;

            p.moisture -= moistureDecayPerSec * seconds;
            p.light -= lightDecayPerSec * seconds;
            p.clean -= cleanDecayPerSec * seconds;

            clampStats(p);

            // health punishment for total abandonment
            if (minutes > 30) {
                p.health -= (minutes - 30) * 0.5 * d.decayFactor;
            }

            p.health = constrain(p.health, 0, 100);
            if (p.health <= 0) {
                p.dead = true;
                p.timeOfDeath = Date.now();
            }
        }

        function clampStats(p) {
            p.moisture = constrain(p.moisture, 0, 100);
            p.light = constrain(p.light, 0, 100);
            p.clean = constrain(p.clean, 0, 100);
        }

        function setup() {
            const canvas = createCanvas(360, 480);
            canvas.parent("game-container");

            pet = loadPet() || newPet();
            lastUpdateMs = millis();

            textFont("system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif");
            const slider = document.getElementById("difficulty-slider");
            const label = document.getElementById("difficulty-label");

            // initialize from saved pet
            slider.value = pet.difficultyIndex;
            label.textContent = difficultyLevels[pet.difficultyIndex].label;

            slider.addEventListener("input", () => {
                pet.difficultyIndex = parseInt(slider.value, 10);
                label.textContent = difficultyLevels[pet.difficultyIndex].label;
                savePet();
            });
        }

        function draw() {
            const nowMs = millis();
            let dt = (nowMs - lastUpdateMs) / 1000.0; // seconds
            // clamp DT so tab-jumps don‚Äôt freak it out
            if (dt > 0.5) dt = 0.5;
            updatePet(dt);
            lastUpdateMs = nowMs;

            renderPet();
        }

        function updatePet(dt) {
            if (!pet) return;

            const difficulty = getDifficulty(pet);
            const moistureDecayPerSec = 0.3;
            const lightDecayPerSec = 0.2;
            const cleanDecayPerSec = 0.05;

            if (!pet.dead) {
                pet.moisture -= 0.3 * difficulty.decayFactor * dt;
                pet.light -= 0.2 * difficulty.decayFactor * dt;
                pet.clean -= 0.05 * difficulty.decayFactor * dt;
                clampStats(pet);

                const inGoodMoisture = pet.moisture >= 40 && pet.moisture <= 70;
                const inGoodLight = pet.light >= 40 && pet.light <= 70;
                const isCleanEnough = pet.clean >= 40;

                if (inGoodMoisture && inGoodLight && isCleanEnough) {
                    pet.health += 0.2 * difficulty.healthFactor * dt;
                } else {
                    pet.health -= 0.3 * difficulty.healthFactor * dt;
                }

                pet.health = constrain(pet.health, 0, 100);

                if (pet.health <= 0 && !pet.dead) {
                    pet.dead = true;
                    pet.timeOfDeath = Date.now();
                }

                if (!pet.dead) {
                    if (!pet.born) {
                        pet.born = Date.now(); // handle older pets
                    }
                    pet.ageSeconds = (Date.now() - pet.born) / 1000; // milliseconds to seconds
                }
            }

            pet._saveAccumulator += dt;
            if (pet._saveAccumulator >= 10) {
                savePet();
                pet._saveAccumulator = 0;
            }
        }

        function renderPet() {
            background(240, 245, 250);

            // --- HEADER TEXT ---
            noStroke();
            fill(30);
            textSize(18);
            textAlign(LEFT, TOP);
            text(pet.dead ? "Your cactus has passed on üíÄ" : "Tiny Terrarium Pet", 16, 16);

            textSize(11);
            fill(80);
            let msg;
            if (pet.dead) {
                msg = "You can start a new one, or leave this shrine of neglect.";
            } else {
                msg = "Keep Water, Light, and Clean in the green for a happy cactus.";
            }
            text(msg, 16, 40, width - 32, 40);

            // --- SPRITES: JAR + CACTUS ---
            const cx = width / 2;

            // jar placement
            const jarW = 260;
            const jarH = 360;
            const jarX = (width - jarW) / 2;
            const jarY = 80;

            // cactus placement & scaling by health
            const healthFactor = pet.health / 100; // 0‚Äì1
            const minScale = 0.6;
            const maxScale = 1.2;
            const scale = minScale + (maxScale - minScale) * healthFactor;

            if (healthFactor < 0.9) {
                image(jarImg, jarX, jarY, jarW, jarH);
            }
            else {
                image(jarOpenImg, jarX, jarY, jarW, jarH);
            }
            jarRect = { x: jarX, y: jarY, w: jarW, h: jarH };

            const baseCactusW = 160;
            const baseCactusH = 180;
            const cactusW = baseCactusW * scale;
            const cactusH = baseCactusH * scale;

            // approximate "dirt top" inside jar
            const dirtTopY = jarY + jarH - 85;

            const cactusX = cx - cactusW / 2;
            const cactusY = dirtTopY - cactusH + 5; // sinks into dirt a bit

            if (healthFactor <= 0) {
                cactusImg = deadCactusImg;
            }
            else if (healthFactor <= 0.4) {
                cactusImg = sadCactusImg;
            }
            else if (healthFactor <= 0.8) {
                cactusImg = okCactusImg;
            }
            else {
                cactusImg = happyCactusImg;
            }
            image(cactusImg, cactusX, cactusY, cactusW, cactusH);

            // --- STAT BARS (ON TOP OF EVERYTHING) ---
            let barX = 16;
            let barY = 330; // << move this up if your canvas is shorter

            drawBar(barX, barY, "Water", pet.moisture);
            barY += 24;
            drawBar(barX, barY, "Light", pet.light);
            barY += 24;
            drawBar(barX, barY, "Clean", pet.clean, true);
            barY += 24;
            drawBar(barX, barY, "Health", pet.health, true);

            // --- AGE / STATUS (ALSO ON TOP) ---
            const ageDays = floor(pet.ageSeconds / 86400);
            let ageLabel = pet.dead ? "RIP" : `Age: ${ageDays} day${ageDays === 1 ? "" : "s"}`;
            noStroke();
            fill(90);
            textAlign(RIGHT, BOTTOM);
            textSize(11);
            text(ageLabel, width - 10, height - 10);

            drawStickers();

            if (decorateOpen) {
                drawTrashCan();
            }
        }

        function drawBar(x, y, label, value, linear = false) {
            const w = width - 32;
            const h = 10;
            noStroke();
            textAlign(LEFT, CENTER);
            textSize(11);
            fill(60);
            text(label, x, y - 7);

            // background
            fill(220);
            rectMode(CORNER);
            rect(x, y, w, h, 999);

            // color by ‚Äúgoodness‚Äù
            let barColor;
            if (value >= 40 && value <= 70) {
                barColor = color(76, 175, 80); // green
                if (linear) {
                    barColor = color(255, 193, 7); // yellow
                }
            } else if (value < 20 || value > 90) {
                barColor = color(213, 0, 0); // red
                if (linear && value > 90) {
                    barColor = color(76, 175, 80); // green
                }
            } else {
                barColor = color(255, 193, 7); // yellow
            }

            fill(barColor);
            const clamped = constrain(value, 0, 100);
            rect(x, y, (w * clamped) / 100, h, 999);
        }

        function drawStickers() {
            if (!pet.stickers) return;

            for (const s of pet.stickers) {
                const img = stickerImgs[s.index];
                const { w, h } = stickerSize(s);

                image(img, s.x - w / 2, s.y - h / 2, w, h);
            }
        }

        function mousePressed() {
            if (!decorateOpen) return;     // << lock stickers unless decorating
            if (isOverTrash(mouseX, mouseY)) return;
            if (!pet || !pet.stickers) return;

            // find topmost sticker under mouse (iterate backwards)
            for (let i = pet.stickers.length - 1; i >= 0; i--) {
                const s = pet.stickers[i];
                const { w, h } = stickerSize(s);

                const left = s.x - w / 2;
                const top = s.y - h / 2;

                if (mouseX >= left && mouseX <= left + w && mouseY >= top && mouseY <= top + h) {
                    activeStickerIndex = i;
                    dragOffsetX = s.x - mouseX;
                    dragOffsetY = s.y - mouseY;

                    // bring to front
                    const picked = pet.stickers.splice(i, 1)[0];
                    pet.stickers.push(picked);
                    activeStickerIndex = pet.stickers.length - 1;

                    return;
                }
            }
        }

        function mouseDragged() {
            if (!decorateOpen) return;     // << lock stickers unless decorating
            if (activeStickerIndex < 0) return;

            const s = pet.stickers[activeStickerIndex];
            s.x = mouseX + dragOffsetX;
            s.y = mouseY + dragOffsetY;

            // optional clamp to canvas bounds
            s.x = constrain(s.x, 0, width);
            s.y = constrain(s.y, 0, height);
        }

        function mouseReleased() {
            if (!decorateOpen) return;
            if (activeStickerIndex < 0) return;

            if (isOverTrash(mouseX, mouseY)) {
                pet.stickers.splice(activeStickerIndex, 1);
            }

            activeStickerIndex = -1;
            savePet();
        }


        function isOverTrash(px, py) {
            return (
                px >= trashRect.x &&
                px <= trashRect.x + trashRect.w &&
                py >= trashRect.y &&
                py <= trashRect.y + trashRect.h
            );
        }

        function drawTrashCan() {
            const pad = 14;
            trashRect.w = 86;
            trashRect.h = 72;
            trashRect.x = width - trashRect.w - pad;
            trashRect.y = height - trashRect.h - pad;

            const hot = (activeStickerIndex >= 0) && isOverTrash(mouseX, mouseY);

            // Palette tuned to your app vibe
            const bg = hot ? color(255, 232, 232) : color(240, 245, 250);   // blush vs soft panel
            const border = hot ? color(210, 60, 60) : color(190, 205, 220); // red vs cool gray
            const ink = hot ? color(170, 30, 30) : color(70, 90, 110);      // dark red vs slate

            // soft shadow (very light)
            noStroke();
            fill(0, 0, 0, 25);
            rect(trashRect.x + 2, trashRect.y + 3, trashRect.w, trashRect.h, 16);

            // body
            fill(bg);
            rect(trashRect.x, trashRect.y, trashRect.w, trashRect.h, 16);

            // border
            noFill();
            stroke(border);
            strokeWeight(2);
            rect(trashRect.x, trashRect.y, trashRect.w, trashRect.h, 16);

            // icon + label
            noStroke();
            fill(ink);
            textAlign(CENTER, CENTER);

            textSize(26);
            text("üóëÔ∏è", trashRect.x + trashRect.w / 2, trashRect.y + 26);

            textSize(11);
            textStyle(BOLD);
            text(hot ? "RELEASE TO" : "DRAG TO", trashRect.x + trashRect.w / 2, trashRect.y + 48);

            textSize(11);
            textStyle(NORMAL);
            text("TRASH", trashRect.x + trashRect.w / 2, trashRect.y + 62);
        }

        // helper for consistent hitbox sizing
        function stickerSize(s) {
            const sz = stickerSizes[s.index];
            return { w: sz.w * s.scale, h: sz.h * s.scale };
        }

        // Button actions ‚Äì this is where the "job" lives
        function giveWater() {
            if (!pet || pet.dead) return;
            pet.moisture = constrain(pet.moisture + 20, 0, 100);
            // pet.health = constrain(pet.health + 2, 0, 100);
            savePet();
        }

        function giveLight() {
            if (!pet || pet.dead) return;
            pet.light = constrain(pet.light + 20, 0, 100);
            // pet.health = constrain(pet.health + 1, 0, 100);
            savePet();
        }

        function cleanJar() {
            if (!pet || pet.dead) return;
            pet.clean = constrain(pet.clean + 20, 0, 100);
            savePet();
        }

        function resetPet() {
            const oldDifficulty =
                pet && typeof pet.difficultyIndex === "number"
                    ? pet.difficultyIndex
                    : 1;

            pet = newPet();
            pet.difficultyIndex = oldDifficulty;

            const slider = document.getElementById("difficulty-slider");
            const label = document.getElementById("difficulty-label");
            slider.value = pet.difficultyIndex;
            label.textContent = difficultyLevels[pet.difficultyIndex].label;

            savePet();
        }

        function toggleStickerDrawer(force) {
            const drawer = document.getElementById("sticker-drawer");
            // const backdrop = document.getElementById("sticker-drawer-backdrop");

            const shouldOpen = typeof force === "boolean" ? force : !drawer.classList.contains("open");
            drawer.classList.toggle("open", shouldOpen);
            // backdrop.classList.toggle("open", shouldOpen);

            decorateOpen = shouldOpen;
        }

        function addSticker(index) {
            // spawn near the top of the jar by default
            const spawnX = jarRect.x + jarRect.w * 0.55;
            const spawnY = jarRect.y + jarRect.h * 0.22;

            const sticker = {
                index,
                x: spawnX,
                y: spawnY,
                scale: 0.5
            };

            pet.stickers.push(sticker);
            savePet();
        }


    </script>
</body>

</html>